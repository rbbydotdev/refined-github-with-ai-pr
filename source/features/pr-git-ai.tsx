/* eslint-diable unicorn/no-abusive-eslint-disable */
/* eslint-disable */

/*
 * ============================================================================
 * PR GIT NOTES FEATURE - AI Attribution Display
 * ============================================================================
 *
 * Goal: Show which lines in a GitHub PR were written by AI
 *
 * How it works:
 * 1. FETCH: Get AI attribution data from git notes/ai refs via GitHub API
 * 2. TRANSFORM: Parse the git notes to extract which lines are AI-generated
 * 3. DISPLAY: Add robot emoji indicators to those lines in the PR diff view
 *
 * Data source: refs/notes/ai contains Git AI Standard format notes that map
 * commit SHAs to files and line ranges that were generated by AI.
 */

import './pr-git-ai.css';

import React from 'dom-chef';
import * as pageDetect from 'github-url-detection';
import { CachedFunction } from 'webext-storage-cache';

import features from '../feature-manager.js';
import api from '../github-helpers/api.js';
import { expectToken } from '../github-helpers/github-token.js';
import {
  cacheByRepo,
  getConversationNumber,
  getRepo,
} from '../github-helpers/index.js';
import { log } from '../helpers/feature-helpers.js';
import observe from '../helpers/selector-observer.js';
import GetPrFileStats from './pr-git-ai-files.gql';

type GitNote = {
	ref: string;
	node_id: string;
	url: string;
	object: {
		sha: string;
		type: string;
		url: string;
	};
};

// File stats from GitHub API
type FileStats = {
	path: string;
	additions: number;
	deletions: number;
};

// Aggregated data from git notes/ai ref
type NotesData = {
	notes: GitNote[];
	notesContent: Record<string, string>;
	aiLineMap: Record<string, number[]>; // Filename -> AI-generated line numbers (final output)
	noRefs?: boolean;
};

// ============================================================================
// PHASE 2: TRANSFORM - Parse git notes to extract AI line numbers
// ============================================================================

/**
 * Parses git note attestation section to find which lines were AI-generated.
 *
 * Input format (Git AI Standard):
 *   src/main.rs
 *     abcd1234abcd1234 1-10,15-20
 *   src/lib.rs
 *     efgh5678efgh5678 25,30-35
 *
 * Output: { "src/main.rs": [1,2,3,4,5,6,7,8,9,10,15,16,17,18,19,20], ... }
 */
function parseAttestation(noteContent: string): Record<string, number[]> {
	const aiLineMap: Record<string, Set<number>> = {};

	const [attestationSection] = noteContent.split('---');
	if (!attestationSection) {
		return {};
	}

	const lines = attestationSection.trim().split('\n');
	let currentFile: string | null = null;

	for (const line of lines) {
		if (!line.startsWith(' ')) {
			// Line with no indentation = file path
			currentFile = line.trim().replaceAll(/^"|"$/g, '');
			continue;
		}

		if (line.startsWith('  ') && currentFile) {
			// Line with 2-space indent = AI attribution entry
			// Format: "  <hash> 1-4,9-10,12"
			const match = /^\s{2}[\da-f]{7,16}\s+(.+)$/.exec(line);
			if (!match) {
				continue;
			}

			const lineRanges = match[1];
			const lineNumbers = expandLineRanges(lineRanges);

			aiLineMap[currentFile] ||= new Set();

			for (const lineNumber of lineNumbers) {
				aiLineMap[currentFile].add(lineNumber);
			}
		}
	}

	// Convert to plain arrays for caching
	const result: Record<string, number[]> = {};
	for (const [file, lineSet] of Object.entries(aiLineMap)) {
		result[file] = [...lineSet];
	}

	return result;
}

// Helper: Expand "1-4,9-10,12" into [1,2,3,4,9,10,12]
function expandLineRanges(rangeString: string): number[] {
	const lineNumbers: number[] = [];
	const parts = rangeString.split(',');

	for (const part of parts) {
		const trimmed = part.trim();
		if (trimmed.includes('-')) {
			const [start, end] = trimmed.split('-').map(Number);
			for (let index = start; index <= end; index++) {
				lineNumbers.push(index);
			}
		} else {
			lineNumbers.push(Number(trimmed));
		}
	}

	return lineNumbers;
}

// Helper: Merge AI line attributions from multiple git notes
function mergeAllAttestations(
	noteContents: string[],
): Record<string, number[]> {
	const allLines: Record<string, Set<number>> = {};

	for (const noteContent of noteContents) {
		const map = parseAttestation(noteContent);
		for (const [file, lines] of Object.entries(map)) {
			allLines[file] ||= new Set();
			for (const line of lines) {
				allLines[file].add(line);
			}
		}
	}

	const result: Record<string, number[]> = {};
	for (const [file, lineSet] of Object.entries(allLines)) {
		result[file] = [...lineSet];
	}

	return result;
}

// ============================================================================
// PHASE 1: FETCH - Get AI attribution data from GitHub
// ============================================================================

/**
 * Fetches git notes from refs/notes/ai and transforms them into a map of
 * filename -> AI line numbers for the PR's HEAD commit.
 *
 * Returns aiLineMap like: { "src/main.rs": [1,2,3,15,16], "src/lib.rs": [25,30,31] }
 */
const getGitNotes = new CachedFunction('git-notes', {
	async updater(): Promise<NotesData> {
		const repo = getRepo();
		if (!repo) {
			return {notes: [], notesContent: {}, aiLineMap: {}};
		}

		try {
			// Fetch refs/notes/ai -> get notes commit -> get tree of note blobs
			const references = await api.v3('git/matching-refs/notes/ai');

			if (!references || references.length === 0) {
				log.info('No refs/notes/ai found');
				return {notes: [], notesContent: {}, aiLineMap: {}, noRefs: true};
			}

			const aiNotesRef = references[0];
			const notesCommit = await api.v3(`git/commits/${aiNotesRef.object.sha}`);
			const notesTree = await api.v3(`git/trees/${notesCommit.tree.sha}`);

			// Read all note blobs (each is a note for one commit SHA)
			const notesContent: Record<string, string> = {};

			for (const treeEntry of notesTree.tree || []) {
				try {
					const blob = await api.v3(`git/blobs/${treeEntry.sha}`);
					const content = atob(blob.content.replaceAll(/\s/g, ''));
					notesContent[treeEntry.path] = content;
				} catch {
					// Ignore errors fetching individual notes
				}
			}

			// Find which lines are AI-generated by parsing notes from ALL commits in the PR
			// (GitHub PR diffs show cumulative changes across all commits)
			let aiLineMap: Record<string, number[]> = {};
			const prNumber = getConversationNumber();

			if (prNumber) {
				try {
					const commits = await api.v3(`pulls/${prNumber}/commits`);

					if (commits && commits.length > 0) {
						// Collect notes for all commits in this PR
						const prCommitShas = new Set(commits.map((c: any) => c.sha));
						const prNotes: string[] = [];

						for (const [commitSha, noteContent] of Object.entries(
							notesContent,
						)) {
							if (prCommitShas.has(commitSha)) {
								prNotes.push(noteContent);
							}
						}

						// Merge AI attributions from all commits
						if (prNotes.length > 0) {
							aiLineMap = mergeAllAttestations(prNotes);
						}
					}
				} catch (error) {
					console.error('Error fetching PR commits:', error);
				}
			}

			return {
				notes: references as unknown as GitNote[],
				notesContent,
				aiLineMap,
			};
		} catch {
			return {notes: [], notesContent: {}, aiLineMap: {}};
		}
	},
	maxAge: {
		hours: 1, // Cache for 1 hour
	},
	cacheKey: cacheByRepo,
});

/**
 * Fetches PR file statistics (additions, deletions) from GitHub API.
 * Returns a map of file path -> stats for quick lookup.
 */
const getPrFileStats = new CachedFunction('pr-file-stats', {
	async updater(): Promise<Record<string, FileStats>> {
		const prNumber = getConversationNumber();
		if (!prNumber) {
			return {};
		}

		try {
			const {repository} = await api.v4(GetPrFileStats, {
				variables: {
					prNumber,
				},
			});

			const fileStats: Record<string, FileStats> = {};
			const files = repository?.pullRequest?.files?.nodes || [];

			for (const file of files) {
				if (file && file.path) {
					fileStats[file.path] = {
						path: file.path,
						additions: file.additions || 0,
						deletions: file.deletions || 0,
					};
				}
			}

			return fileStats;
		} catch (error) {
			console.error('Error fetching PR file stats:', error);
			return {};
		}
	},
	maxAge: {
		hours: 1, // Cache for 1 hour
	},
	cacheKey: cacheByRepo,
});

// ============================================================================
// PHASE 3: DISPLAY - Add robot emoji indicators to AI-generated lines
// ============================================================================

/**
 * Calculates AI vs human percentage for a file based on the authoritative git notes data.
 * Uses file stats from GitHub API as the single source of truth.
 */
function calculateFilePercentages(
	filePath: string,
	aiLines: number[],
	fileStats: Record<string, FileStats>,
): {
	aiCount: number;
	humanCount: number;
	aiPercentage: number;
	humanPercentage: number;
} {
	// The aiLines array IS the source of truth - it contains exactly which lines are AI-generated
	const aiCount = aiLines.length;

	// Get total additions from API data (single source of truth)
	const stats = fileStats[filePath];
	const totalAdditions = stats?.additions || 0;

	// Fallback: if we don't have stats, assume aiLines represents all additions we know about
	const effectiveTotal = totalAdditions > 0 ? totalAdditions : aiCount;

	const humanCount = effectiveTotal - aiCount;
	const aiPercentage =
		effectiveTotal > 0 ? Math.round((aiCount / effectiveTotal) * 100) : 0;
	const humanPercentage =
		effectiveTotal > 0 ? Math.round((humanCount / effectiveTotal) * 100) : 0;

	return {
		aiCount,
		humanCount,
		aiPercentage,
		humanPercentage,
	};
}

/**
 * Adds PR-level total AI/Human percentage indicator to the toolbar.
 */
async function addPrTotalIndicator(): Promise<void> {
	try {
		// Find toolbar - use attribute selector for stability
		// Look for the section element that contains the toolbar
		const toolbar = document.querySelector(
			'section[class*="PullRequestFilesToolbar"][class*="toolbar"]',
		);

		if (!toolbar) {
			return;
		}

		// Find the last div child of the toolbar (right side section)
		// The toolbar uses justify-content: space-between, so we want to append to the last child
		const toolbarChildren = toolbar.querySelectorAll(':scope > div');
		const lastToolbarSection = toolbarChildren[toolbarChildren.length - 1];

		let loadingIndicator = document.querySelector('.rgh-ai-pr-loading-indicator');
		if (!loadingIndicator) {
			loadingIndicator = (
				<div className="rgh-ai-pr-loading-indicator" title={`Loading Git AI`}>
					<span className="rgh-ai-pr-loading-label">üîÑ Loading Git AI</span>
				</div>
			);

			if (lastToolbarSection) {
				lastToolbarSection.append(loadingIndicator);
			} else {
				// Fallback: just append to toolbar
				toolbar.append(loadingIndicator);
			}
		}

		// Fetch both AI line data and file stats from API (single source of truth)
		const notesData = await getGitNotes.get();
		const fileStats = await getPrFileStats.get();
		const {aiLineMap, noRefs} = notesData;

		// Check if indicator already exists
		if (toolbar.querySelector('.rgh-ai-pr-total-indicator')) {
			return;
		}

		// Calculate totals across all files
		// Iterate through API data (single source of truth) instead of scraping DOM
		let totalAiLines = 0;
		let totalHumanLines = 0;

		for (const [filePath, aiLines] of Object.entries(aiLineMap)) {
			if (!aiLines || aiLines.length === 0) {
				continue;
			}

			// Calculate for this file using API data
			const {aiCount, humanCount} = calculateFilePercentages(
				filePath,
				aiLines,
				fileStats,
			);

			totalAiLines += aiCount;
			totalHumanLines += humanCount;
		}

		const total = totalAiLines + totalHumanLines;
		let indicator = document.querySelector('rgh-ai-pr-total-indicator');
		//remove loading indicator

    loadingIndicator?.remove();
		if (!indicator) {
			if (total > 0) {
				const aiPercentage = Math.round((totalAiLines / total) * 100);
				const humanPercentage = Math.round((totalHumanLines / total) * 100);
				indicator = (
					<div
						className="rgh-ai-pr-total-indicator"
						title={`AI: ${aiPercentage}% (${totalAiLines} lines) ¬∑ Human: ${humanPercentage}% (${totalHumanLines} lines)`}
					>
						<span className="rgh-ai-pr-total-label">PR Total:</span>
						<span className="rgh-ai-percentage-ai">ü§ñ {aiPercentage}%</span>
						<span className="rgh-ai-percentage-human">
							üë§ {humanPercentage}%
						</span>
					</div>
				);
			} else if (noRefs) {
				indicator = (
					<div className="rgh-ai-pr-total-indicator" title={`No Git AI`}>
						<span className="rgh-ai-pr-total-label">‚ùå No Git AI</span>
					</div>
				);
			}

			if (indicator) {
				if (lastToolbarSection) {
					lastToolbarSection.append(indicator);
				} else {
					// Fallback: just append to toolbar
					toolbar.append(indicator);
				}
			}
		}
	} catch (error) {
		console.error('[RGH AI PR Total] Error adding PR total indicator:', error);
	}
}

/**
 * Adds AI/Human percentage indicator to the file diff header.
 * Expects diffContainer to be the actual diff element containing rows, not the header.
 */
async function addPercentageIndicator(diffContainer: Element): Promise<void> {
	try {
		// Skip if this is just a header wrapper without rows
		const hasRows = diffContainer.querySelector('tr.diff-line-row');
		if (!hasRows) {
			return;
		}

		// Fetch both AI line data and file stats from API (single source of truth)
		const notesData = await getGitNotes.get();
		const fileStats = await getPrFileStats.get();
		const {aiLineMap} = notesData;

		if (Object.keys(aiLineMap).length === 0) {
			return;
		}

		// Get filename - use attribute selectors to avoid brittle module hashes
		const fileNameCode = diffContainer.querySelector(
			'[class*="file-name"] code, .file-info code',
		);

		if (!fileNameCode) {
			return;
		}

		const filePath = fileNameCode.textContent
			.replaceAll(/[\u200E\u200F\u202A-\u202E]/g, '')
			.trim();

		const aiLines = aiLineMap[filePath];

		if (!aiLines || aiLines.length === 0) {
			return;
		}

		// Calculate percentages using API data
		const {aiPercentage, humanPercentage, aiCount, humanCount} =
			calculateFilePercentages(filePath, aiLines, fileStats);

		// Find the file path section to insert the indicator
		// Use attribute selector to match class containing both meaningful parts
		const filePathSection = diffContainer.querySelector(
			'[class*="file-path-section"], .file-info',
		);

		if (!filePathSection) {
			return;
		}

		// Check if indicator already exists
		if (filePathSection.querySelector('.rgh-ai-percentage-indicator')) {
			return;
		}

		// Create percentage indicator
		const indicator = (
			<div
				className="rgh-ai-percentage-indicator"
				title={`AI: ${aiPercentage}% ¬∑ Human: ${humanPercentage}%`}
			>
				<span className="rgh-ai-percentage-ai">ü§ñ {aiPercentage}%</span>
				<span className="rgh-ai-percentage-human">üë§ {humanPercentage}%</span>
			</div>
		);

		filePathSection.append(indicator);
	} catch (error) {
		console.error('[RGH AI %] Error adding percentage indicator:', error);
	}
}

/**
 * Checks if a diff row contains an AI-generated line and adds a robot emoji indicator.
 *
 * Process:
 * 1. Get the filename from the diff header
 * 2. Get the line number from the row
 * 3. Check if aiLineMap[filename] includes this line number
 * 4. If yes, add robot emoji ü§ñ next to the line number
 */
async function markAiGeneratedLines(row: HTMLElement): Promise<void> {
	try {
		const notesData = await getGitNotes.get();

		const {aiLineMap} = notesData;

		if (Object.keys(aiLineMap).length === 0) {
			return;
		}

		// Extract filename from diff header
		// Use attribute selectors to avoid brittle module hashes
		const diffContainer = row.closest(
			'[class*="Diff-module__diff"], .file, diff-layout',
		);

		if (!diffContainer) {
			return;
		}

		const fileNameCode = diffContainer.querySelector(
			'[class*="file-name"] code, .file-info code',
		);

		if (!fileNameCode) {
			return;
		}

		const filePath = fileNameCode.textContent
			.replaceAll(/[\u200E\u200F\u202A-\u202E]/g, '')
			.trim();

		// Extract line number from the row using data-line-number attribute
		const lineNumberCell = row.querySelector(
			'td[data-line-number]',
		) as HTMLElement;

		if (!lineNumberCell) {
			return;
		}

		const lineNumber = Number(lineNumberCell.dataset.lineNumber);

		if (!lineNumber) {
			return;
		}

		// Check if this file:line is AI-generated
		const aiLines = aiLineMap[filePath];

		if (!aiLines) {
			return;
		}

		// If match found, add robot emoji indicator
		if (aiLines.includes(lineNumber)) {
			// Determine if this is an addition or deletion
			// Check if the old line number cell (cells[0]) is empty (addition) or has a number (deletion)
			// const oldLineCell = row.querySelector('td[data-line-number]');
			const isAddition = lineNumberCell.dataset.diffSide === 'right';

			row.dataset.rghAiGenerated = 'true';
			row.dataset.rghAiType = isAddition ? 'addition' : 'deletion';

			if (!lineNumberCell.querySelector('.rgh-ai-indicator')) {
				lineNumberCell.style.position = 'relative';
				lineNumberCell.append(
					<span className="rgh-ai-indicator" title="AI-generated code">
						ü§ñ
					</span>,
				);
			}
		}
	} catch (error) {
		console.error('[RGH AI Line] Error marking AI-generated line:', error);
	}
}

// ============================================================================
// INITIALIZATION
// ============================================================================

async function init(signal: AbortSignal): Promise<void> {
	await expectToken();

	// Add PR-level total indicator to toolbar
	void addPrTotalIndicator();

	// Watch for toolbar changes (e.g., when it becomes sticky)
	observe(
		'[class*="PullRequestFilesToolbar"]',
		() => {
			void addPrTotalIndicator();
		},
		{signal},
	);

	// Add percentage indicators to existing file headers
	// Use stable selectors: attribute selectors for module classes, semantic classes, or custom elements
	const existingDiffs = document.querySelectorAll(
		'[class*="Diff-module__diff"], .file, diff-layout',
	);

	for (const diffContainer of existingDiffs) {
		void addPercentageIndicator(diffContainer);
	}

	// Watch for new file diffs (e.g., when user navigates or expands diffs)
	observe(
		['[class*="Diff-module__diff"]', '.file', 'diff-layout'],
		(diffContainer) => {
			void addPercentageIndicator(diffContainer);
			// Update PR total when new diffs load
			void addPrTotalIndicator();
		},
		{signal},
	);

	// Mark AI lines in existing diff rows
	const existingRows = document.querySelectorAll('tr.diff-line-row');
	for (const row of existingRows) {
		void markAiGeneratedLines(row as HTMLElement);
	}

	// Watch for new diff rows (e.g., when user expands collapsed diffs)
	observe(
		'tr.diff-line-row',
		(row) => {
			void markAiGeneratedLines(row);
		},
		{signal},
	);
}

// Register feature to run on PR files page
void features.add(import.meta.url, {
	include: [pageDetect.isPRFiles],
	init,
});

/*

Test URLs:

https://github.com/refined-github/refined-github/pull/1/files

*/
